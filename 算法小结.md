<!-- TOC -->

- [随手记一下自己在刷题过程中遇到的小算法](#随手记一下自己在刷题过程中遇到的小算法)
  - [排序](#排序)
    - [拓扑排序](#拓扑排序)
      - [1.概念](#1概念)
      - [2.BFS法入度表法](#2bfs法入度表法)
      - [3.DFS法（出度表法）](#3dfs法出度表法)

<!-- /TOC -->
# 随手记一下自己在刷题过程中遇到的小算法

## 排序
### [拓扑排序](https://www.cxyxiaowu.com/1084.html)
#### 1.概念
拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：
1. 每个顶点出现且只出现一次。
2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。
有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说
**拓扑排序问题的核心就是出入度，即前驱和后继的关系**

#### 2.BFS法[入度表法](https://www.jianshu.com/p/b59db381561a)
入度表法是根据顶点的入度来判断是否存在依赖关系。若顶点入度不为0。则必然此顶点的事件有前驱依赖事件，因此每次选取入度为0的顶点输出，则符合拓扑排序的性质。  
所以定义的时候，需要的是每个节点的入度组成的数组，以及每个节点的下一个节点数组组成的二维数组。即**后继二维数组+入度**，这样既可以遍历后继，也可以判断每个节点是否入度是零，是否要输出（是否是前驱）
算法执行流程: 
1. 从图中选择一个入度为0的顶点，输出该顶点。
2. 从图中删除该节点及其所有出边（即与之邻接的所有顶点入度-1）
3. 反复执行这两个步骤，直至所有节点都输出，即整个拓扑排序完成；或者直至剩下的图中再没有入度为0的节点，这就说明此图中有回路，不可能进行拓扑排序。
#### 3.DFS法（出度表法）
深度优先搜索过程中，当到达出度为0的顶点时，需要进行回退。在执行回退时记录出度为0的顶点，将其入栈。则最终出栈顺序的逆序即为拓扑排序序列。  
算法执行流程：
1. 对图执行深度优先搜索。
2. 在执行深度优先搜索时，若某个顶点不能继续前进，即顶点的出度为0，则将此顶点入栈。
3. 最后得到栈中顺序的逆序即为拓扑排序顺序。