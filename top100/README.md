# Tips: 就随手记录下刷题过程中解题思路
<!-- TOC -->

- [Tips: 就随手记录下刷题过程中解题思路](#tips-就随手记录下刷题过程中解题思路)
  - [11.盛最多水的容器](#11盛最多水的容器)
    - [method1 仿照快排的思路](#method1-仿照快排的思路)
      - [题后反思](#题后反思)
      - [原始思路](#原始思路)
  - [15.三数之和【核心：不重复】](#15三数之和核心不重复)
    - [method1 自己的思路](#method1-自己的思路)
    - [难点突破——如何做到不重复](#难点突破如何做到不重复)
    - [further——三层循环的里面两层是否可以替换成快排的双指针](#further三层循环的里面两层是否可以替换成快排的双指针)
  - [17.电话号码的字母组合](#17电话号码的字母组合)
    - [一刷卡壳的知识点](#一刷卡壳的知识点)
  - [19.删除链表的倒数第N个节点](#19删除链表的倒数第n个节点)
    - [小思考，如何从动态规划的角度解决此问题](#小思考如何从动态规划的角度解决此问题)
  - [20.有效的括号](#20有效的括号)
    - [improve——一刷没有注意到的点](#improve一刷没有注意到的点)
  - [21.合并两个有序链表](#21合并两个有序链表)
    - [improve——一刷没有注意到的点](#improve一刷没有注意到的点-1)
  - [22.括号生成](#22括号生成)
    - [一刷时错误想法](#一刷时错误想法)
    - [此题采用深度优先算法的理解方式](#此题采用深度优先算法的理解方式)
    - [超时问题原因分析](#超时问题原因分析)
  - [31.下一个排列](#31下一个排列)
    - [看了题解以后的思路](#看了题解以后的思路)
  - [33.搜索旋转排序数组](#33搜索旋转排序数组)
    - [owner mind](#owner-mind)
    - [官方解法1——二分法查找法](#官方解法1二分法查找法)
  - [39.组合总和](#39组合总和)
    - [owner mind](#owner-mind-1)
    - [题解感悟](#题解感悟)
      - [想法专业名词化——之前想到过这个做法，但是不知道用法专业名词是啥](#想法专业名词化之前想到过这个做法但是不知道用法专业名词是啥)
      - [优化项1——边界条件的确定可以提高代码质量](#优化项1边界条件的确定可以提高代码质量)
      - [优化项2——本地并不需要对原有数据进行排序](#优化项2本地并不需要对原有数据进行排序)
  - [46.全排列](#46全排列)
    - [owner mind](#owner-mind-2)
    - [看了题解以后的思路](#看了题解以后的思路-1)
  - [48.旋转图像](#48旋转图像)
    - [看了题解以后的感悟](#看了题解以后的感悟)
  - [49.字母异位次分组](#49字母异位次分组)
    - [看了题解以后的感悟](#看了题解以后的感悟-1)
  - [50.最大子序和](#50最大子序和)
    - [owner mind](#owner-mind-3)
    - [题解](#题解)
  - [55.跳跃游戏](#55跳跃游戏)
  - [看了题解以后的感悟](#看了题解以后的感悟-2)
  - [56.合并区间——此题需要重刷](#56合并区间此题需要重刷)
  - [看了题解以后的感悟](#看了题解以后的感悟-3)
  - [62.不同路径](#62不同路径)
    - [看了题解以后的感悟](#看了题解以后的感悟-4)
  - [64.最小路径和](#64最小路径和)
  - [70.爬楼梯](#70爬楼梯)
  - [75.颜色分类](#75颜色分类)
    - [看题解以后的思路](#看题解以后的思路)
  - [78.子集](#78子集)
- [算法笔记](#算法笔记)
  - [先序遍历和深度优先算法的内核](#先序遍历和深度优先算法的内核)
  - [贪心算法和动态规划使用的时机](#贪心算法和动态规划使用的时机)

<!-- /TOC -->

## 11.盛最多水的容器
### method1 仿照快排的思路
####  题后反思
此题应该仿照快排两个角度去思考：
1. 左右指针的移动，左右指针的左右移动，选择移动哪一方是根据如何获取最大容量决定的
2. 计算最大容量，为了保证最大容量，短板的那一方就要不断往另一方移动，保证另一方变成短板，否则容量只减不增

之前做题的时候有两点错误：
1. `height[leftPointer] == height[rightPointer]`时该怎么处理呢，是否有必要单独作为一种情况去写逻辑。
    * 错误的做法就是单独作为一种情况去判断。遇到这种情况不妨静下来思考下，如果作为同一条件去处理是否会出现问题。
    * 将==的情况合并入<的情况，即`height[leftPointer] <= height[rightPointer]`时，`leftPointer++`，此时`leftPointer`固定时，右板必定比左板矮，然后移动右板找一个更高的板。
    * 本质就是不管先移动左板还是先移动右板,都是等到**双方都固定在更高的位置**，才有可能比原来的容量大，因为只固定一方，容量=短板一方*宽度，宽度肯定是比移动以前要小的
2. 单侧移动是否直接移动到比前一次高度更高的位置，直接减少后续的计算

#### 原始思路
左右指针，左右指针以此向内移动。注意核心水的容量取决于短板
1. 左右先比大小，小的往内移动，直到找到高度比原来高的，否则容量必定不可能更大
2. 计算此时容量是否比之前的大
3. 只有容量大了才替换左右指针的值，然后继续步骤1
函数终止的边界条件，左指针指>=右指针时，函数终止
Q:左右指针一样大的时候，该移动哪个呢，要同时往里移动，因为两个都是短板，改变任意一个都没得用。左右先各找到比之前大的位置，如果都是比之前小的，容量只会越来越小，所以左右指针找到更大的点然后重新执行上述的流程

问题：逻辑复杂，代码又臭又长
    
## 15.三数之和【核心：不重复】
### method1 自己的思路
三元素想到了对应三个元素，先固定a，然后固定b，然后右边的子集中查找是是否存在c = -（a+b）

**此题有一个难点，就是如何区分重复的组合list，因为二维数组里面会有多个重复的元素，遍历过程中可能会遇到重复的元素组成的重复组合，所以需要先排序，然后看这个list是否存在**  
很显然是愚蠢的，排序需要额外的耗时，查找又是额外的耗时

### 难点突破——如何做到不重复
「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：

第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；

第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。

接下来的就是思考边界条件和初始化条件了：
* 边界条件：nums[n] > nums[n-1]，可以发现三层的初始位置nums[2]减一后回到第二层初始位置nums[1]（第二层和第一层的关系也是同理），比如{-4, 2, 2}这样的组合，就不能使用`nums[n] > nums[n-1]`的边界条件了。否则这种情况就不会被记入。结论:（下一层nums位置 = 上一层nums位置+1） && (num[n] > nums[n-1])
* 特殊条件：除了边界条件可以发现，有一个特殊的vector，那就是{0, 0, 0}的组合

### further——三层循环的里面两层是否可以替换成快排的双指针
第一层固定a后，b+c=-a

## 17.电话号码的字母组合
考点：
* 字符串的分割
* 映射，一个字符对应一个数组
* 组合
**第一时间没有很好的思路，先看答案吧**  
**答案关键词：广度优先**
### 一刷卡壳的知识点
* `string&`  `const string&` `const char`有什么区别；string可以用数组的形式去拿内部元素。
* for循环遍历字符串
* 广度优先搜索算法遗忘太久了

## 19.删除链表的倒数第N个节点
两层遍历的情况简单易懂，以下是第一轮刷题没有做到的点：
* 在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。
* 栈的角度属实是没有想到
* 一次遍历的新思路也是没有想到的——**快慢指针，使用双指针遍历,first比second超前了n个节点**

### 小思考，如何从动态规划的角度解决此问题
动态规划经典三步走：
1. 定义数组元素含义
2. 找出数组元素之间的关系式
3. 确认边界条件和初始值

## 20.有效的括号
此题一拿到手，就想起了开心消消乐的感觉，首尾要成对——消除，自然想到了队列这个特殊的数据结构了——垃圾，想错了

傻逼，这个成对消除，`{[]}`，成对消除的核心是从左往右遍历的时候，n和n+1成对才可以消失，自然想到的应该是**堆栈**：成对则栈顶依次出站，不成对则入栈

此题没有看出下一状态(容量) = 上一状态（容量）+ * 这样的清晰的逻辑，所以不考虑动态规划

### improve——一刷没有注意到的点
* 字符串为奇数，直接返回false
* 判断是否成对出现可以采用**哈希map**
* `({[`这三个符号可以直接push，因为他们只能等待被成对消除

## 21.合并两个有序链表
其实还是简单的，搞一个哑巴节点，两个节点依次比较值，小的那个加入哑巴节点的链表，小的链表后移重复上述操作

### improve——一刷没有注意到的点
* 初始值为空的情况，直接返回就好了，这都是编程习惯，记得养成
* 递归的思想没有很好的利用，此题还有一种递归的思路

## 22.括号生成
### 一刷时错误想法
画树状图的时候发现，好想可以用递归的思路去理解——下一状态和上一状态相关。**这是错误思路：有些状态其实左右括号都可以，所以为什么不考虑深度优先算法和广度优先算法呢**
* 如果左括号=n或者前面的左右括号都成对了，那么只能加右括号；否则左右括号都可以

### 此题采用深度优先算法的理解方式
先看[注释1]先序遍历的的解释，此题节点可以对应为目前结果的状态：
```
visit() {
    if (满足条件1) {
        string对象新增{;
        visit(往左下遍历);
        string对象删掉{;
    }
    if (满足条件2) {
        string对象新增};
        visit(往右下遍历);
        string对象删掉};
    }
}
```
**此题切记不要死搬`visit(p->left)和visit(p->right)`，应该从状态树的角度思考，怎么从根节点到左下节点然后进行遍历，又怎么从左下角节点回到根节点，再从根节点来到右下节点进行遍历**

### 超时问题原因分析
以下代码缺点分析：
1. generateParenthesis在调用generate的时候并不需要返回值，所以定义generate的时候应该用void类型
2. 其次，leftCount, rightCount这些用完就丢的东西，在generateParenthesis中也没有使用价值，并不需要定义类型，直接传值进去就可以了：`generate(n, 0, 0, results, result);` **问题1+2就很简单的两行代码，直接就搞定了超时问题，所以代码能力一定要过关呀**
3. 边界条件`if (leftCount + rightCount == 2 * n)`满足执行以后直接return，下面的逻辑会多走过多的判断耗时
4. 二叉树的右侧树判断条件可以由`if (leftCount - rightCount > 0 && rightCount < n)`精简为`f (close < open)`
``` C++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        int leftCount = 0, rightCount = 0;
        vector<string> results;
        string result = "";
        if (n == 0) {
            return results;
        }
        generate(n, leftCount, rightCount, results, result);
        return results;
    }

    vector<string> generate(int n, int leftCount, int rightCount, vector<string> &results, string &result) {
        if (leftCount + rightCount == 2 * n) {
            results.push_back(result);
        }

        if (leftCount < n) {
            result.push_back('(');
            generate(n, leftCount + 1, rightCount, results, result);
            result.pop_back();
        }

        if (leftCount - rightCount > 0 && rightCount < n) {
            result.push_back(')');
            generate(n, leftCount, rightCount + 1, results, result);
            result.pop_back();
        }
    
    return results;
    }
};
```

## 31.下一个排列
**本题就没有读懂题干，先看了对题目的解读。关键内容：**
* 可以将问题描述转化为：给定若干个数字，将其组合为一个整数。如何将这些数字重新排列，以得到下一个更大的整数。如 123 下一个更大的数为 132
* 没有看具体解法，只是看了对题干的分析没有看解法，自己想到的方法——从数组的尾部进行遍历，如果前比后小，那么直接调换，如果前比后大，指针往前

**以上思路只能保证调换后的数比之前的要大，但是不能保证是比之前数据大的所有集合中最小的，最小是问题的关键**

### 看了题解以后的思路
* 步骤1——从后往前遍历，前数比后数小，大的数和小的数互换位置，能保证当前数比之前的数要大，但是并不能保证是大的集合中最小的那个，比如`25341`变成`25431`，事实上应该是`25413`
* 步骤2——所以另一个核心就是保证当前数比之前数变大的幅度是最小的，也就是3和4互换位置以后,**3以后的序列要进行升序排列，这点是一刷的时候没有想到的**
总结为一般规律以后，就是要讲最大的和次大的互换位置，次大以后的序列进行升序遍历。因此可以考虑确定步骤1以后的前数以后，从后面子序中找出次大的调换位置后，讲后面子序进行快排，也就是需要四次遍历，效率极低

```
while (j >= 0 && nums[i] >= nums[j]) {
    j--;
}
```
这段代码的理解：因为是从后往前，找前数比后数小的，也就是说子序中的前数都比后数大，即满足降序，只需要从中找出比nums[i]大的数，就是大幅最小的数据了。因为i,j数据互换前，有`nums[j+1] > nums [j] > nums[j-1]和nums[j] > nums[i]`，而while只会在`nums[j] > nums[i]`的时候停止，所以有`nums[i] > nums[j-1]`  
总结：`nums[j+1] > nums [j] > nums[i] > nums[j-1]`，所以i，j互换位置以后，并不需要快速排序，只需要降序变升序`reverse()`即可

自己写代码的时候还有一处没有考虑到
```C++
if (point >= 0) {
```
因为跳出第一个while循环的时候，也有可能是point<0导致的

## 33.搜索旋转排序数组
**本题第一眼拿到题目没有反应过来旋转数组是什么玩意**

### owner mind
* 整个数组可以分为两个部分，从前往后的升序数组+从后往前的降序数组
* 若target >= nums[0]，那么遍历升序数组，否则遍历降序数组
* 遍历升序数组：while (target >= nums[i]) 遍历，遍历停止的时候nums[i] != target就是不存在了
* 遍历降序数组也是同理

### 官方解法1——二分法查找法
因为整个数组旋转前是有序的，将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。
对有序部分采用二分查找法：
* 如果 [l, mid - 1] 是有序数组，且 target 的大小满足: nums[l] <= nums[target] <= nums[mid - 1]，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。  
如果 [mid, r] 是有序数组，且 target 的大小满足:nums[mid + 1] < nums[target] <= nums[r]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。  

## 39.组合总和
想起了数据结构里面的一个结构，但是我给忘了，草

### owner mind
看到这题第二反应是递归，递就完事了

### 题解感悟
#### 想法专业名词化——之前想到过这个做法，但是不知道用法专业名词是啥
此题有点像图问题的DFS，将其进阶为搜索回溯法  
将整个搜索过程想象为一棵树的形式

#### 优化项1——边界条件的确定可以提高代码质量
```C++
//写法1
if(target - candidates[i] == 0) {
    result.push_back(candidates[i]);
    results.push_back(result);
    result.pop_back();
}
if (target - candidates[i] > 0) {
    result.push_back(candidates[i]);
    find(candidates, target - candidates[i], results, result, i);
    result.pop_back();
}

// 写法2
if (target == 0) {
    results.push_back(result);
}
if (target - candidates[i] > 0) {
    result.push_back(candidates[i]);
    find(candidates, target - candidates[i], results, result, i);
    result.pop_back();
}
```
很明显写法2这种边界条件可以直接少了一层push和pop的代码量

#### 优化项2——本地并不需要对原有数据进行排序
本地的核心是不要有重复的一元数组，即[2,2,3]和[2,3,2]这种形式上的差异。也就是说index一旦走到下一个元素，DFS搜索下一个节点的时候，数组的左右区间就是[index, length]，而不是[0,length]，否则还是会有重复的问题

## 46.全排列
### owner mind
此题拿到手就知道是典型的`搜索回溯法`，但是这个剪枝的操作要求：元素中去除掉某个元素，然后继续遍历其他元素。  
考虑到去除某个元素其本质就是标志某个成员已经被访问，可以用一个`vector`，访问对应位置成员则将vector对应值置位1

### 看了题解以后的思路
* 如何不利用vector数组标记遍历过的节点，将数组分成两组，左边的是已经访问过的，右边的是未访问过的，每次访问就把当前访问过的和未访问的进行swap

## 48.旋转图像
本题要求不适用另一个矩阵来旋转图像。  
此题想到了结合线性代数去理解，但是并没有做出来

### 看了题解以后的感悟
此题旋转90度本质上相当于矩阵转置+翻转  
矩阵转置——

## 49.字母异位次分组
### 看了题解以后的感悟
**这类将不同属性成员归类成一个个同属性子集的题目都可以考虑使用哈希映射的方式**  
hashmap来维护重复数组：key为具有相同属性的描述，value为具有相同属性  
* 方法1——key代表的是字符串1进行字符排序后的字符串1，value代表的是排序后字符串1相同的字符串2的合集
* 方法2——同样是哈希映射，key value所代表的含义发生了变化，记住哈希映射的核心是key选取的规则；
  key——将字符串散列化为`#`分隔的字符串，比如`abbcc`就可以散列化为`1#2#2#0....#0`;当然这是很蠢的一种写法，可以直接忽略，直接考虑方法1。

## 50.最大子序和
### owner mind
无
### 题解
老动态规划了，但是没有想到。首先
1. 首先分治法——要求数组中最大子序和转化为：
  * nums[i]结尾的最大子序，`0<=i<length`，并把结果存在数组maxCa[i]里面
  * maxCa[i]里面最大的结果最大子序和
2. 子问题处理：如何计算`nums[i]`结尾的最大子序，使用动态规划处理问题
  * 定义数组元素含义：maxCa[i]表示nums[i]结尾的最大子序
  * 数组之间的关系：`maxCa[i] = (maxCa[i-1] + nums[i] > nums[i]) ? maxCa[i-1] + nums[i] : nums[i]`
  * 确定边界条件和初始值：`i=0`时，`maxCa[i]=nums[i]`；

## 55.跳跃游戏
典型深度优先算法，可以把数组想象成图的形状，`nums[i]`为3，表示跳跃的最大长度是3；也就是nums[i]可以跳跃到nums[i+1]、nums[i+2]、nums[i+3]

考虑到本题的算法时间复杂度，可以每次跳跃的步长都是`nums[i]`的值即，每次跳当前所能跳的最长的步数，但是还是没能解决超时问题。

## 看了题解以后的感悟
本地使用深度优先算法为什么会出问题：**不遍历数组，按当前位置所能到的最大位置去跳跃只会找到局部最长路径**，比如`[3,2,5,0,4]`这种数组，从0跳跃到3，然后发现到达不了，就的从0跳至2，再去遍历。最糟糕的时候会出现时间复杂度>>O（n）的情况，具体的时间复杂度计算方式有时间再去看吧。  
所以不如选择踏踏实实遍历。  
所以题解中的贪心法确实是更好的方法

## 56.合并区间——此题需要重刷
本地核心就是区间x右标>区间y左标，那么区间x，y就是可以合并的。稍微有点难点就是时间复杂度问题。从复杂的角度去看，有可能存在第x+1个区间比x区间要小的可能，尽量去减少区间与区间之间各种复杂的情况，就直接一个一个遍历就好了。  
还是猜题目是有序的情况吧，如果是无序的情况太复杂了。————果然是不对的
## 看了题解以后的感悟
1. 首先区间数组可能是无序的，所以需要排序
2. 数组是不能进行删减的，并且插入操作是非常麻烦的，所以考虑使用动态数组List，最后将List转化为静态数组就可以了

## 62.不同路径
本题之前看知乎的时候看到过解法了，属于**后一状态取决于之前的多个状态**，直接考虑使用动态规划。  
* 定义数组元素含义——不妨设`location[i][j]`表示到达坐标中(i,j)位置共有的路径。由于机器人只能往右或者往下移动一步，所以显然可得  
* 数组之间的关系：`location[i][j] = location[i-1][j] + location[i][j -1]`  
* 确定边界条件和初始值：`location[0][0] = 1`，`location[0][j] = 1`，`location[i][0] = 1`

### 看了题解以后的感悟
还有一个递归加剪枝的思路

## 64.最小路径和
本题其实和62题是一样的，直接用动态规划就解决了

## 70.爬楼梯
典型的动态规划题
* 定义数组元素含义——result[i]表示到达第i个阶梯有的方式
* 数组之间的关系——result[i] = result[i-1] + result[i-2],i>1
* 确定边界条件和初始值result[0]=0, result[1]=1, result[2]=2;

## 75.颜色分类
其实也就是典型的排序题，如果用笨一点的方法，直接快排就可以解决此问题。本题的难点就是如何使用一个常数空间一趟排序结束。  
思路1：
* 首先数组的插入十分耗时，所以肯定要用list，排序结束以后转成数组
* 用三 个index指向红白蓝的队尾，每次都向队尾插入新的元素
* 最后还要讲list转成数组赋值给输入数组
这个思路实现了一趟排序，但是算法空间`S(n) = O(n)`
首先这个来回转换加赋值就很傻逼

### 看题解以后的思路
* 首先就不需要三个index，考虑到只需要把其中两个排序好，另一个颜色自然也就是有序的了，所以只需要两个Index
* 其次选择红白和红蓝都可以，但是一定要注意每次swap的时候都要做特殊处理，具体细节不写了，每次看到问题主动去回忆 

## 78.子集
本题想到一个比较蠢的方法，假设数组的长度是N
采用深度优先算法+剪枝的方式去解决重复元素的问题；其中要注意每次遍历的子节点中加上空节点这样的情况。
剪枝的条件：当前缓存的数组中包含子节点即[1,2]以后再进行深度遍历就不再遍历1、2元素的节点。
**本题最重要的体验就是遍历到子节点返回父节点以后，除了结果以外的所有内容都要恢复至父节点原位**

本题自己写的方法实在是太挫了，记得重写遍题解的做法








# 算法笔记
DFS和回溯法的区别：
* 回溯是会“剪枝”的穷举，回溯搜索也是深度优先算法的一种
* 回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。

## 先序遍历和深度优先算法的内核
**内核：**可以把图看做二叉树，从二叉树的角度去分析，先序遍历访问顺序如下
```C++
visit() {
    对根节点p进行操作;
    visit(p->left);
    visit(p->right);
}
```

但是要注意在递归执行`visit(p->left)和visit(p->right)`的时候，不要死板的只会套二叉树。核心就是访问根节点p的其中一个节点，然后返回根节点p，再访问根节点的另一个节点[注释1]。而深度优先算法是升级版的先序遍历，用于解决图的问题，她遍历的是根节点所连接的所有节点，伪代码如下：
```C++
visit() {
    对根节点p进行操作；
    visit(p->节点1)；
    visit(p->节点2);
    visit(p->节点3);
    ...以此类推；
}
```


## 贪心算法和动态规划使用的时机
状态转移树中，若后一状态仅仅取决于上一个状态，就用贪婪算法；若后一状态取决于之前的多个状态，就用动态规划。