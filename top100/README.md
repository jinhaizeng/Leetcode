# Tips: 就随手记录下刷题过程中解题思路

## 11.盛最多水的容器
### method1 仿照快排的思路
####  题后反思
此题应该仿照快排两个角度去思考：
1. 左右指针的移动，左右指针的左右移动，选择移动哪一方是根据如何获取最大容量决定的
2. 计算最大容量，为了保证最大容量，短板的那一方就要不断往另一方移动，保证另一方变成短板，否则容量只减不增

之前做题的时候有两点错误：
1. `height[leftPointer] == height[rightPointer]`时该怎么处理呢，是否有必要单独作为一种情况去写逻辑。
    * 错误的做法就是单独作为一种情况去判断。遇到这种情况不妨静下来思考下，如果作为同一条件去处理是否会出现问题。
    * 将==的情况合并入<的情况，即`height[leftPointer] <= height[rightPointer]`时，`leftPointer++`，此时`leftPointer`固定时，右板必定比左板矮，然后移动右板找一个更高的板。
    * 本质就是不管先移动左板还是先移动右板,都是等到**双方都固定在更高的位置**，才有可能比原来的容量大，因为只固定一方，容量=短板一方*宽度，宽度肯定是比移动以前要小的
2. 单侧移动是否直接移动到比前一次高度更高的位置，直接减少后续的计算

#### 原始思路
左右指针，左右指针以此向内移动。注意核心水的容量取决于短板
1. 左右先比大小，小的往内移动，直到找到高度比原来高的，否则容量必定不可能更大
2. 计算此时容量是否比之前的大
3. 只有容量大了才替换左右指针的值，然后继续步骤1
函数终止的边界条件，左指针指>=右指针时，函数终止
Q:左右指针一样大的时候，该移动哪个呢，要同时往里移动，因为两个都是短板，改变任意一个都没得用。左右先各找到比之前大的位置，如果都是比之前小的，容量只会越来越小，所以左右指针找到更大的点然后重新执行上述的流程

问题：逻辑复杂，代码又臭又长

### 小思考，如何从动态规划的角度解决此问题
动态规划经典三步走：
1. 定义数组元素含义
2. 找出数组元素之间的关系式
3. 确认边界条件和初始值

此题没有看出下一状态(容量) = 上一状态（容量）+ * 这样的清晰的逻辑，所以不考虑动态规划

## 贪心算法和动态规划使用的时机
状态转移树中，若后一状态仅仅取决于上一个状态，就用贪婪算法；若后一状态取决于之前的多个状态，就用动态规划。