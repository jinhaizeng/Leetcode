# Tips: 就随手记录下刷题过程中解题思路

## 11.盛最多水的容器
### method1 仿照快排的思路
####  题后反思
此题应该仿照快排两个角度去思考：
1. 左右指针的移动，左右指针的左右移动，选择移动哪一方是根据如何获取最大容量决定的
2. 计算最大容量，为了保证最大容量，短板的那一方就要不断往另一方移动，保证另一方变成短板，否则容量只减不增

之前做题的时候有两点错误：
1. `height[leftPointer] == height[rightPointer]`时该怎么处理呢，是否有必要单独作为一种情况去写逻辑。
    * 错误的做法就是单独作为一种情况去判断。遇到这种情况不妨静下来思考下，如果作为同一条件去处理是否会出现问题。
    * 将==的情况合并入<的情况，即`height[leftPointer] <= height[rightPointer]`时，`leftPointer++`，此时`leftPointer`固定时，右板必定比左板矮，然后移动右板找一个更高的板。
    * 本质就是不管先移动左板还是先移动右板,都是等到**双方都固定在更高的位置**，才有可能比原来的容量大，因为只固定一方，容量=短板一方*宽度，宽度肯定是比移动以前要小的
2. 单侧移动是否直接移动到比前一次高度更高的位置，直接减少后续的计算

#### 原始思路
左右指针，左右指针以此向内移动。注意核心水的容量取决于短板
1. 左右先比大小，小的往内移动，直到找到高度比原来高的，否则容量必定不可能更大
2. 计算此时容量是否比之前的大
3. 只有容量大了才替换左右指针的值，然后继续步骤1
函数终止的边界条件，左指针指>=右指针时，函数终止
Q:左右指针一样大的时候，该移动哪个呢，要同时往里移动，因为两个都是短板，改变任意一个都没得用。左右先各找到比之前大的位置，如果都是比之前小的，容量只会越来越小，所以左右指针找到更大的点然后重新执行上述的流程

问题：逻辑复杂，代码又臭又长
    
## 15.三数之和【核心：不重复】
### method1 自己的思路
三元素想到了对应三个元素，先固定a，然后固定b，然后右边的子集中查找是是否存在c = -（a+b）

**此题有一个难点，就是如何区分重复的组合list，因为二维数组里面会有多个重复的元素，遍历过程中可能会遇到重复的元素组成的重复组合，所以需要先排序，然后看这个list是否存在**  
很显然是愚蠢的，排序需要额外的耗时，查找又是额外的耗时

### 难点突破——如何做到不重复
「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证：

第二重循环枚举到的元素不小于当前第一重循环枚举到的元素；

第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。

接下来的就是思考边界条件和初始化条件了：
* 边界条件：nums[n] > nums[n-1]，可以发现三层的初始位置nums[2]减一后回到第二层初始位置nums[1]（第二层和第一层的关系也是同理），比如{-4, 2, 2}这样的组合，就不能使用`nums[n] > nums[n-1]`的边界条件了。否则这种情况就不会被记入。结论:（下一层nums位置 = 上一层nums位置+1） && (num[n] > nums[n-1])
* 特殊条件：除了边界条件可以发现，有一个特殊的vector，那就是{0, 0, 0}的组合

### further——三层循环的里面两层是否可以替换成快排的双指针
第一层固定a后，b+c=-a

## 17.电话号码的字母组合
考点：
* 字符串的分割
* 映射，一个字符对应一个数组
* 组合
**第一时间没有很好的思路，先看答案吧**  
**答案关键词：广度优先**
### 一刷卡壳的知识点
* `string&`  `const string&` `const char`有什么区别；string可以用数组的形式去拿内部元素。
* for循环遍历字符串
* 广度优先搜索算法遗忘太久了

## 19.删除链表的倒数第N个节点
两层遍历的情况简单易懂，以下是第一轮刷题没有做到的点：
* 在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。
* 栈的角度属实是没有想到
* 一次遍历的新思路也是没有想到的——**快慢指针，使用双指针遍历,first比second超前了n个节点**

### 小思考，如何从动态规划的角度解决此问题
动态规划经典三步走：
1. 定义数组元素含义
2. 找出数组元素之间的关系式
3. 确认边界条件和初始值

此题没有看出下一状态(容量) = 上一状态（容量）+ * 这样的清晰的逻辑，所以不考虑动态规划

## 贪心算法和动态规划使用的时机
状态转移树中，若后一状态仅仅取决于上一个状态，就用贪婪算法；若后一状态取决于之前的多个状态，就用动态规划。